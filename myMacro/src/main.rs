//!宏（Macro）
//!使用 macro_rules! 的 声明（Declarative）宏，和三种 过程（Procedural）宏：
//!
//!1、自定义 #[derive] 宏在结构体和枚举上指定通过 derive 属性添加的代码
//!2、类属性（Attribute-like）宏定义可用于任意项的自定义属性
//!3、类函数宏看起来像函数不过作用于作为参数传递的 token
//!
//! 宏是一种为写其他代码而写代码的方式，即所谓的 元编程（metaprogramming）
//!
//! 宏扮演了函数扮演的角色。但宏有一些函数所没有的附加能力。
//! 1、一个函数签名必须声明函数参数个数和类型。相比之下，宏能够接收不同数量的参数：
//! 2、宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait。而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现。
//! 3、实现宏不如实现函数的一面是宏定义要比函数定义更复杂，因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。
//! 4、宏和函数的最后一个重要的区别是：在一个文件里调用宏 之前 必须定义它，或将其引入作用域，而函数则可以在任何地方定义和调用。
fn main() {
    println!("Hello, world!");
}
